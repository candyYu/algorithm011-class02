###  XOR 异或操作
```
X^0 = X
X^1s= ~X //注意1s=~0
x ^ (~x) = 1s
x^x=0
c=a^b => a^c=b,b^c=a  //交换两个数
a^b^c=a^(b^c)=(a^b)^c
// associative
```


### 比较常见的位运算
```
1. 将x最右边的n位清零:x&(~0<<n)   
2. 获取x的第n位值(0或者1):(x>>n)&1
3. 获取x的第n位的幂值:x&(1<<n)
4. 仅将第n位置为1:x|(1<<n)
5. 仅将第n位置为0:x&(~(1<<n))
6. 将x最高位至第n位(含)清零:x&((1<<n)-1)
7. 将第n位至第0位(含)清零:x&(~((1<<(n+1))-1))

```

### 实战位运算
```
• 判断奇偶:
x%2==1 —>(x&1)==1 
x%2==0 —>(x&1)==0

• x>>1—>x/2.
即: x=x/2; —> x=x>>1;
mid=(left+right)/2; —> mid=(left+right)>>1;

X=X&(X-1)清零最低位的1

X&-X=>得到最低位的 1

X&~X=>0

如何获取二进制中最右边的 1：x & (-x)。
如何将二进制中最右边的 1 设置为 0：x & (x - 1)。

在补码表示法中，-x = ~x+1。换句话说，要计算 −x，则要将 x 所有位取反再加 1。

```


## 实战题目
LeetCode 190 颠倒二进制位

```
  public int reverseBits(int n) {
        int a=0;
        for(int i=0;i<=31;i++){
            a=a+((1&(n>>i))<<(31-i));
        }
        return a;
    
    }
    
    //十进制：ans = ans * 10 + n % 10; n = n / 10;
    //二进制：ans = ans * 2 + n % 2; n = n / 2;
     public int reverseBits(int n) {
        int res = 0;
        for (int i = 0; i < 32; i++) {
            res = (res << 1) + (n & 1);
            n >>= 1;
        }
        return res;
    }
    
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        n = (n >>> 16) | (n << 16); 
        n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8); 
        n = ((n & 0xf0f0f0f0) >>> 4) | ((n & 0x0f0f0f0f) << 4); 
        n = ((n & 0xcccccccc) >>> 2) | ((n & 0x33333333) << 2); 
        n = ((n & 0xaaaaaaaa) >>> 1) | ((n & 0x55555555) << 1); 
        return n;
    }
```

第三种解法  分治合并解法
```
// 原数字43261596
 0000 ‭0010 1001 0100 _ 0001 1110 1001 1100‬ 
// 反转左右16位：
‭ 0001 1110 1001 1100 _ 0000 0010 1001 0100‬ 
// 继续分为8位一组反转：
 1001 1100 0001 1110 _ 1001 0100 0000 0010
// 4位一组反转：
 1100 1001 1110 0001 _ 0100 1001 0010 0000‬
// 2位一组反转：
 0011 0110 1011 0100 _ 0001 0110 1000 0000
// 每两位再反转一下
‭ 0011 1001 0111 1000 _ 0010 1001 0100 0000‬‬
// 这就是43261596反转后的结果：‭964176192‬
```

我们通过 x & (-x) 保留了最右边的 1，并将其他位设置为 0 若 x 为 2 的幂，则它的二进制表示中只包含一个 1，则有 x & (-x) = x。
